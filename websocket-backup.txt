const { Transcriber } = require('./helpers');
const { Chat } = require('./models/chat');
const { MessageWS } = require('./models/messageWS');
const { User } = require('./models/user');

const users = new Map(); // socketId => userId
const watchers = new Map(); // userId => Set(socketIds)

// üîπ –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –æ–Ω–æ–≤–ª–µ–Ω–Ω—è –Ω–æ–≤–∏—Ö –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
const updateUserNewMessages = async (userId) => {
  try {
    const allChats = await Chat.find({ users: userId })
    const newMessageIds = [];
    allChats.forEach((chat) => {
      const userIndex = chat.users.indexOf(userId)
      if (userIndex === 0) {
        newMessageIds.push(...chat.newMessagesUserOne)
      } else if (userIndex === 1) {
        newMessageIds.push(...chat.newMessagesUserTwo)
      }
    })

    await User.findByIdAndUpdate(userId, {
      newMessages: newMessageIds,
    });

  } catch (err) {
    throw new Error(err);
  }
};

const initializeWebSocket = (io) => {
  io.on('connection', async (socket) => {
    const userId = socket.handshake.query.userId
    users.set(socket.id, userId)
    // eslint-disable-next-line no-console
    console.log(`üü¢ User connected: ${userId} (${socket.id})`)

    // üîî –Ø–∫—â–æ —Ö—Ç–æ—Å—å –≤–∂–µ —Å–ø–æ—Å—Ç–µ—Ä—ñ–≥–∞—î –∑–∞ —Ü–∏–º userId ‚Äî –ø–æ–≤—ñ–¥–æ–º–ª—è—î–º–æ —ó—Ö
    if (watchers.has(userId)) {
      watchers.get(userId).forEach((socketId) => {
        io.to(socketId).emit('user-online', userId)
      })
    }

    // üîπ –û–±—Ä–æ–±–∫–∞ –ø—ñ–¥–ø–∏—Å–∫–∏ –Ω–∞ –æ–Ω–ª–∞–π–Ω-—Å—Ç–∞—Ç—É—Å
    socket.on('watch-user', ({ targetUserId }) => {
      if (!targetUserId) return
      if (!watchers.has(targetUserId)) {
        watchers.set(targetUserId, new Set())
      }
      watchers.get(targetUserId).add(socket.id)
      // eslint-disable-next-line no-console
      console.log(`üëÅÔ∏è ${userId} is watching ${targetUserId}`)

      // –Ø–∫—â–æ targetUserId –≤–∂–µ –æ–Ω–ª–∞–π–Ω ‚Äî –æ–¥—Ä–∞–∑—É –ø–æ–≤—ñ–¥–æ–º–ª—è—î–º–æ
      if ([...users.values()].includes(targetUserId)) {
        socket.emit('user-online', targetUserId)
      }
    })

    // üîπ –û–±—Ä–æ–±–∫–∞ –≤—ñ–¥–ø–∏—Å–∫–∏
    socket.on('unwatch-user', ({ targetUserId }) => {
      if (!targetUserId || !watchers.has(targetUserId)) return
      watchers.get(targetUserId).delete(socket.id)
      if (watchers.get(targetUserId).size === 0) {
        watchers.delete(targetUserId)
      }
      // eslint-disable-next-line no-console
      console.log(`üö´ ${userId} stopped watching ${targetUserId}`)
    })

    // ------üîπ –õ–û–ì–Ü–ö–ê –¢–†–ê–ù–°–ö–†–ò–ü–¶–Ü–á  ------
    const transcriber = new Transcriber()

    transcriber.on('transcriber-ready', () => {
      socket.emit('transcriber-ready', 'Ready')
    })

    transcriber.on('final', (transcript) => {
      socket.emit('final', transcript)
    })

    transcriber.on('final-transleted', (transletedResponse) => {
      socket.emit('final-transleted', transletedResponse)
    })

    transcriber.on('partial', (transcript) => {
      socket.emit('partial', transcript)
    })

    transcriber.on('error', (error) => {
      socket.emit('error', error)
    })

    transcriber.on('close', (data) => {
      socket.emit('close', data)
    })

    socket.on('incoming-audio', async (data) => {
      if (!transcriber.deepgramSocket) {
        await transcriber.startTranscriptionStream(
          data.sampleRate,
          data.inputLanguage
        )
        transcriber.send(data.audioData, data.targetLanguage)
      } else {
        transcriber.send(data.audioData, data.targetLanguage)
      }
    })

    socket.on('pause-deepgram', (data) => {
      transcriber.pauseTranscriptionStream(data)
    })

    socket.on('diconnect-deepgram', () => {
      transcriber.endTranscriptionStream()
    })

    // ------üîπ –õ–û–ì–Ü–ö–ê –ß–ê–¢–£  ------
    socket.on(
      'create-chat',
      async ({ userId, ownerId, apartmentId }, callback) => {
        try {
          let chat = await Chat.findOne({
            users: { $all: [userId, ownerId] },
            propertyId: apartmentId,
          })

          if (!chat) {
            chat = new Chat({
              users: [userId, ownerId],
              propertyId: apartmentId,
            })
            await chat.save()
          }

          // eslint-disable-next-line no-console
          console.log(`üÜï Chat created (or found): ${chat._id}`)
          // ‚úÖ –í—ñ–¥–ø—Ä–∞–≤–ª—è—î–º–æ chatId —É callback –∑ `null` —è–∫ –ø–µ—Ä—à–∏–π –ø–∞—Ä–∞–º–µ—Ç—Ä (–±–µ–∑ –ø–æ–º–∏–ª–∫–∏)
          callback(null, { chatId: chat._id.toString() })
        } catch (error) {
          // eslint-disable-next-line no-console
          console.error('Error creating chat:', error)
          callback(error, null)
        }
      }
    )

    // üîπ –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —á–∏ —î —á–∞—Ç
    socket.on(
      'check-chat',
      async ({ userId, ownerId, apartmentId }, callback) => {
        try {
          const chat = await Chat.findOne({
            users: { $all: [userId, ownerId] },
            propertyId: apartmentId,
          })
          if (!chat) {
            callback(null, null)
          } else {
            // eslint-disable-next-line no-console
            console.log(`Chat found): ${chat._id}`)
            callback(null, { chatId: chat._id.toString() })
          }
        } catch (error) {
          // eslint-disable-next-line no-console
          console.error('Error creating chat:', error)
          callback(error, null)
        }
      }
    )

    // üîπ –ó–±–∏—Ä–∞—î–º–æ –≤—Å—é –ø–µ—Ä–µ–ø–∏—Å–∫—É
    socket.on('conversation', async ({ chatId }, callback) => {
      try {
        const chat = await Chat.findById(chatId)
        if (!chat) {
          callback(null, null)
        }
        // –û—Ç—Ä–∏–º—É—î–º–æ –≤—Å—ñ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è —Ü—å–æ–≥–æ —á–∞—Ç—É, —Å–æ—Ä—Ç—É—î–º–æ –∑–∞ –¥–∞—Ç–æ—é —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è
        const messages = await MessageWS.find({ chatId }).sort({ createdAt: 1 })
        // –î–æ–¥–∞—î–º–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ –≤ –∫—ñ–º–Ω–∞—Ç—É WebSocket
        socket.join(chatId)
        // –ü–æ–≤–µ—Ä—Ç–∞—î–º–æ —ñ—Å—Ç–æ—Ä—ñ—é —á–∞—Ç—É —Ç–∞ —Å–∞–º —á–∞—Ç
        callback(null, { messages, chat })
      } catch (error) {
        // eslint-disable-next-line no-console
        console.error('Error fetching chat messages:', error)
        callback(error, null)
      }
    })

    // üîπ –í—ñ–¥–ø—Ä–∞–≤–∫–∞ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
    socket.on('message', async ({ chatId, senderId, text }, callback) => {
      try {
        const sender = await User.findById(senderId)
        if (!sender) {
          throw new Error(`Chat not found: ${chatId}`)
        }
        const chat = await Chat.findById(chatId)
        if (!chat) {
          throw new Error(`Chat not found: ${chatId}`)
        }
        const message = new MessageWS({
          chatId,
          senderId,
          text,
          senderAvatar: sender.userAvatar,
          senderName: sender.username,
        })
        await message.save()
        const senderIndex = chat.users.indexOf(senderId)
        const updateField =
          senderIndex === 0
            ? { $push: { newMessagesUserTwo: message._id } }
            : { $push: { newMessagesUserOne: message._id } }

        await Chat.findByIdAndUpdate(chatId, {
          ...updateField,
          lastMessage: text,
          lastMessageAt: Date.now(),
        })

        await updateUserNewMessages(chat.users[1 - senderIndex])

        // üîî –°–ø–æ–≤—ñ—â–∞—î–º–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞, —â–æ –π–æ–º—É –Ω–∞–¥—ñ–π—à–ª–æ –Ω–æ–≤–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è, —Ç—Ä–µ–±–∞ –æ–Ω–æ–≤–∏—Ç–∏ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
        const recipientId = chat.users[1 - senderIndex]
        for (const [socketId, id] of users.entries()) {
          if (id === recipientId) {
            io.to(socketId).emit('user-new-message')
          }
        }

        io.to(chatId).emit('message', { senderId, text, createdAt: new Date() })
        callback(null, { info: 'Message sent' })
      } catch (error) {
        // eslint-disable-next-line no-console
        console.error('‚ùå Error sending message:', error)
        callback(error, null)
      }
    })

    // üîπ –û—Ç—Ä–∏–º—É—î–º–æ –∞–≤–∞—Ç–∞—Ä –≤–ª–∞—Å–Ω–∏–∫–∞ –ø–æ–º–µ—à–∫–∞–Ω–Ω—è
    socket.on('owner-avatar', async ({ ownerId }, callback) => {
      try {
        const owner = await User.findById(ownerId)
        if (!owner) {
          callback(null, null)
        } else {
          callback(null, {
            info: { avatar: owner.userAvatar, name: owner.username },
          })
        }
      } catch (error) {
        // eslint-disable-next-line no-console
        console.error('Error creating chat:', error)
        callback(error, null)
      }
    })

    // üîπ –í–∏–¥–∞–ª—è—î–º–æ –Ω–æ–≤—ñ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –¥–ª—è –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
    socket.on(
      'clear-new-messages',
      async ({ chatId, field, userId }, callback) => {
        if (!chatId || !field || !userId) return
        try {
          const chat = await Chat.findById(chatId)
          if (!chat) throw new Error(`Chat not found: ${chatId}`)

          const clearedIds =
            field === 'newMessagesUserOne'
              ? [...chat.newMessagesUserOne]
              : [...chat.newMessagesUserTwo]

          await Chat.findByIdAndUpdate(chatId, {
            [field]: [],
          })

          await User.findByIdAndUpdate(userId, {
            $pull: { newMessages: { $in: clearedIds } },
          })

          // üîî –ü–æ–≤—ñ–¥–æ–º–ª—è—î–º–æ –∫–ª—ñ—î–Ω—Ç —â–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –≤–∏–¥–∞–ª–µ–Ω–æ, –Ω–µ–æ–±—Ö—ñ–¥–Ω–æ –æ–Ω–æ–≤–∏—Ç–∏ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
          for (const [socketId, id] of users.entries()) {
            if (id === userId) {
              io.to(socketId).emit('user-new-message')
            }
          }

          callback(null, { message: 'Success' })
          // eslint-disable-next-line no-console
          console.log(`üßπ Cleared ${field} for chat ${chatId}`)
        } catch (error) {
          // eslint-disable-next-line no-console
          console.error('Error clearing new messages:', error)
        }
      }
    );


    // üîπ –û–±—Ä–æ–±–∫–∞ –≤—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è
    socket.on('disconnect', () => {
      const userId = users.get(socket.id)
      users.delete(socket.id)
      // eslint-disable-next-line no-console
      console.log(`üî¥ User disconnected: ${socket.id} (userId: ${userId})`)

      // üîî –°–ø–æ–≤—ñ—â–∞—î–º–æ –≤—Å—ñ—Ö, —Ö—Ç–æ —Å–ª—ñ–¥–∫—É—î –∑–∞ —Ü–∏–º userId
      if (userId && watchers.has(userId)) {
        watchers.get(userId).forEach((socketId) => {
          io.to(socketId).emit('user-offline', userId)
        })
      }

      // ‚ùóÔ∏è –î–æ–¥–∞—Ç–∫–æ–≤–æ ‚Äî –æ—á–∏—â–∞—î–º–æ —Ü–µ–π —Å–æ–∫–µ—Ç –∑ —É—Å—ñ—Ö watcher'—ñ–≤
      for (const [watchedId, socketSet] of watchers.entries()) {
        socketSet.delete(socket.id)
        if (socketSet.size === 0) {
          watchers.delete(watchedId)
        }
      }
    })
  })

  return io
}

module.exports = initializeWebSocket